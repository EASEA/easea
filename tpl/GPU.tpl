\TEMPLATE_START// -*- mode: c++; c-indent-level: 2; c++-member-init-indent: 8; comment-column: 35; -*-
//
// (The above line is useful in Emacs-like editors)
//
//****************************************
//                                         
//  EASEA.cpp
//                                         
//  C++ file generated by AESAE-CUDA v0.9a
//                                         
//****************************************

 


#define GPU_BUFFER_POS(buffer,index) (buffer+sizeof(EASEAGenome)*index)
\ANALYSE_PARAMETERS
#define ONLY_RESULT
#define MINIMAL_VERBOSE
#define MARGIN 5         // margin between cpu and gpu evaluation (only in mixed mode)
//#define MARGIN_ERROR   // if defined margin margin errors are fatal
//#define FULL_VERBOSE

#include <unistd.h>
#include <stdio.h>
#include "tool/tool.h"
#define TIMING
#include "tool/timing.h"
#include <opt.h>
#include <float.h>
#include <time.h>


#ifdef TOTAL_TIMING
struct timeval total_time;
#endif

#ifdef MEMCPY_TIMING
struct timeval total_memcopy_time;
#endif

#ifdef DATAMOTION_TIMING
struct timeval data_motion_t;
#endif

#ifdef KRNL_TIMING
struct timeval krnl_t;
#endif

#ifdef CPUCOMPUTE_TIMING
struct timeval cpu_compute_time;
#endif





#define PRESSION_SELECTION \SELECT_PRM
#define PRESSION_REPLACEMENT \RED_FINAL_PRM

#include "EASEAUserFunc.h"
#include "EASEAIndividual.h"  //Generated individual
#include <iostream>



//**************************************************
// 
//     At exec time variables 
//     and default values
//
//**************************************************
float fPMut=\MUT_PROB;
float fPCross=\XOVER_PROB; 

int bElitisme=1;
bool bGPGPU = true;

size_t nTAILLE_POP = \POP_SIZE;
size_t nOFFSPRINGSIZE = \OFF_SIZE;
size_t nNB_GENERATION = \NB_GEN;


//INSERT_INITIALISATION_FUNCTION 
\INSERT_INITIALISATION_FUNCTION 






int
DEBUG_evalPopulation(char* parentGenomes, CIndividu** pPopParents, size_t popSize){
  int i;
  int ret = true;


  for (i=0;i<popSize;i++)
    pPopParents[i]->evaluation();
    
  return ret;
}


//static inline size_t tournoi(CIndividu** population, size_t popSize, size_t pression){
size_t tournoi(CIndividu** population, size_t popSize, size_t pression){
  size_t meilleurIndividu = 0;
  float meilleurFitness;
  if( \MINIMAXI )
    meilleurFitness = -FLT_MAX;
  else
    meilleurFitness = FLT_MAX;

  for( size_t i = 0 ; i<pression ; i++ ){
    size_t index = getRandomIntMax(popSize);
    //fprintf(stderr,"random selected index : %d  addr : % p fitness : %f \n",index, population[index], population[index]->nFitness);
#if \MINIMAXI
      if(population[index]->nFitness > meilleurFitness){
	meilleurFitness = population[index]->nFitness;
	meilleurIndividu = index;
      }
#else
      if(population[index]->nFitness < meilleurFitness){
	meilleurFitness = population[index]->nFitness;
	meilleurIndividu = index;
	
      }
#endif
  }
#ifdef FULL_VERBOSE
  fprintf(stderr,"meilleurIndividu %d\n",meilleurIndividu);
#endif
  return meilleurIndividu;
}



CIndividu* selection(CIndividu** population, size_t popSize){
  size_t meilleurIndividu = tournoi(population,popSize,PRESSION_SELECTION);
  return population[meilleurIndividu];
}


int compareIndividuals(const void* a, const void* b){
  const CIndividu* i1 = *(const CIndividu**)a;
  const CIndividu* i2 = *(const CIndividu**)b;
  if( i1->nFitness < i2->nFitness)
    return -1;
  else 
    if( i1->nFitness > i2->nFitness )
      return 1;
    else
      return 0;
  //return ((float)(i1->nFitness - i2->nFitness));
}


void sortPopulation(CIndividu** population, size_t popSize){
  
  qsort(population,popSize,sizeof(CIndividu*),compareIndividuals);

}

CIndividu* remplacement(CIndividu** population, size_t popSize){
  //size_t meilleurIndividu = tournoi(population,popSize,PRESSION_REPLACEMENT);
  size_t meilleurIndividu = popSize-1;
  CIndividu* selected = population[meilleurIndividu];

  //suppression de l'individu selectionne de la population courante
  population[meilleurIndividu] = population[popSize-1];
  return selected;
}






float returnedFitness;
int mainLoop(int argc,char** argv){
	
	
  /// declarations
	
  //FILE *fpFichierSauvegarde;
  CIndividu *tPop1[nTAILLE_POP+nOFFSPRINGSIZE]; 
  CIndividu *tPop2[nTAILLE_POP+nOFFSPRINGSIZE];
  CIndividu **pTemp;
	
  CIndividu **pPopCourante=(CIndividu **) tPop1;
  CIndividu **pNouvellePop=(CIndividu **) tPop2;
	
  CIndividu **pPopParents=pPopCourante; // Pointeur sur la population de parents
  CIndividu **pPopEnfants=&(pPopCourante[nTAILLE_POP]); // Pointeur sur
  char* parentGenomes = (char*)malloc(sizeof(EASEAGenome)*nTAILLE_POP);
  char* offspringGenomes = (char*)malloc(sizeof(EASEAGenome)*nOFFSPRINGSIZE);

  int i,nNbEnfants=0,nTailleNouvellePop=0,nTaillePopCourante=0;
  size_t generationCourante = 0;
	
	
#ifndef ONLY_RESULT
  printf( "\n----> Cre'ation de la population : \n");
#endif
	
  // Cre'ation et initialisation de la population
  for (i=0;i<nTAILLE_POP;i++) {
    pPopParents[i]=new CIndividu(NULL);


#ifndef ONLY_RESULT
    printf("\npPopParents[%d]=%p\n",i,pPopParents[i]); 
#endif

  }


  // initialize pseudo-random generator to current time
  srand(time(0));
  
  for( i=nTAILLE_POP; i<nOFFSPRINGSIZE ; i++)
    pPopEnfants[i] = NULL;
  
  for( i=0 ; i<nTAILLE_POP+nOFFSPRINGSIZE; i++)
    pNouvellePop[i] = NULL;

#ifndef ONLY_RESULT
  printf("\n----> Evaluation de la population \n");
#endif
	
  // Evaluation pour cre'er une population de parents
  
//   if( bGPGPU ){
//     gpuEvaluation(parentGenomes,pPopParents,nTAILLE_POP);
//   }
//   else
//     for (i=0;i<nTAILLE_POP;i++)
//       pPopParents[i]->evaluation();

  if(!DEBUG_evalPopulation(parentGenomes,pPopParents,nTAILLE_POP))
    return -1;
  

#ifndef ONLY_RESULT
  for (i=0;i<nTAILLE_POP;i++)
    printf("%s\n",pPopParents[i]->toString().c_str());
#endif
  
  while( generationCourante < nNB_GENERATION ){


#if defined(FULL_VERBOSE) && !defined(ONLY_RESULT)
    printf("La PopParents contient :\n");
    for(i=0;i<nTAILLE_POP;i++)
      printf("%p, ",pPopParents[i]);

    printf("\n");
    printf("\n");
    printf("-----------------------------------------------------------------");
    printf("\n");
#endif

		
    while (nNbEnfants<nOFFSPRINGSIZE){   // boucle sur la taille des enfants			
      if (randomLoc(0,1)<fPCross) { // ope'rateur binaire (croisement) 

#if defined(MINIMAL_VERBOSE) && !defined(ONLY_RESULT)
	printf("\nCroisement : ");
#endif
				
	CIndividu *i1,*i2;
	i1=selection(pPopParents,nTAILLE_POP);
				
	do{
	  i2=selection(pPopParents,nTAILLE_POP);    // 
	} while (i2 ==i1); // Moui, c'est pas oblige' mais pourquoi pas...
	//rajouter un and afin de  stopper en cas de convergence
				
	if (randomLoc(0,1)<0.5) // micro-subtilite'... ;-)
	  pPopEnfants[nNbEnfants]=i1->croisement(i2,NULL);  
	else  
	  pPopEnfants[nNbEnfants]=i2->croisement(i1,NULL);

        #if defined(MINIMAL_VERBOSE) && !defined(ONLY_RESULT)
	printf("%p + %p = %p\n",i1,i2,pPopEnfants[nNbEnfants]);
        #endif

      }
      else { // ope'rateur unaire (clonage)
	CIndividu *i1;
				
	i1=selection(pPopParents,nTAILLE_POP);  //Il faut e'crire la se'lection
	//pPopEnfants[nNbEnfants]=new CIndividu(i1,GPU_BUFFER_POS(offspringGenomes,nNbEnfants));
	pPopEnfants[nNbEnfants]=new CIndividu(i1,NULL);


#if defined(FULL_VERBOSE) && !defined(ONLY_RESULT)
	printf("Clonage: %p clone' en %p\n",i1,pPopEnfants[nNbEnfants]);
#endif
      }
      
      //printf("\nMutation de %p\n",pPopEnfants[nNbEnfants]);      
      pPopEnfants[nNbEnfants]->mutation(fPMut,GPU_BUFFER_POS(offspringGenomes,nNbEnfants)); // mutation.

      nNbEnfants++;
    }
    // Bon, et bien on est maintenant au complet (parents + enfants)
    // Il faut maintenant e'valuer tous les enfants
    

    #if defined(FULL_VERBOSE) && !defined(ONLY_RESULT)
    printf("\n");
    printf("-----------------------------------------------------------------");
    printf("\n");
    #endif


    if(!DEBUG_evalPopulation(offspringGenomes,pPopEnfants,nOFFSPRINGSIZE))
      return -1;
      


    #if defined(MINIMAL_VERBOSE) && !defined(ONLY_RESULT)
    for (i=0;i<nOFFSPRINGSIZE;i++)
      printf("%s\n",pPopEnfants[i]->toString().c_str());
    printf("\n\n");
    #endif
		

    // Il faut maintenant remplir la nouvelle population et on raisonne
    // maintenant en population globale parents+enfants
		
    nTaillePopCourante=nTAILLE_POP+nOFFSPRINGSIZE;
    nTailleNouvellePop=0;

    #ifndef ONLY_RESULT		
    printf("La PopCourante contient :\n");
    for(i=0;i<nTaillePopCourante;i++)
      printf("%p (%f), ",pPopParents[i],pPopParents[i]->nFitness);
    printf("\n");
    #endif
		
    // Si on de'cide qu'il y a de l'e'litisme, on commence par un e'litisme mou
		
    if (bElitisme){
			
      int iMeilleur=0;
      for (i=1;i<nTaillePopCourante;i++)

        #if \MINIMAXI
	  if (pPopCourante[i]->nFitness>pPopCourante[iMeilleur]->nFitness)
	    iMeilleur=i;
        #else
	  if (pPopCourante[i]->nFitness<pPopCourante[iMeilleur]->nFitness)
	    iMeilleur=i;
        #endif 
				
      pNouvellePop[0]=pPopCourante[iMeilleur];
			
      #ifndef ONLY_RESULT
      printf("----> Elitisme : on recopie %p dans la population d'enfants\n",pNouvellePop[0]);
      #endif
				
      // Maintenant, on supprime de la population courante l'individu
      // qui a e'te' tranfe're' dans la nouvelle population
      pPopCourante[iMeilleur]=pPopCourante[nTaillePopCourante-1];
      nTaillePopCourante--; nTailleNouvellePop++;
    }
		
    #ifndef ONLY_RESULT
    printf("----> Remplacement\n");
    printf("----> Re'capitulatif avant Remplacement:\npPopCourante contient les individus :\n");
    for( i=0;i<nTaillePopCourante;i++)
      printf("%s\n",pPopCourante[i]->toString().c_str());
    #endif
		
    
    // remplacement part
    sortPopulation(pPopCourante,nTaillePopCourante); // this is for deterministic replacement (this will be handled in a better way later)

    while(nTailleNouvellePop<nTAILLE_POP){
      pNouvellePop[nTailleNouvellePop]=remplacement(pPopCourante,nTaillePopCourante);

      #if defined(MINIMAL_VERBOSE) && !defined(ONLY_RESULT)
      printf("the elected one is : %s",pNouvellePop[nTailleNouvellePop]->toString().c_str());
      #endif

      nTaillePopCourante--; 
      nTailleNouvellePop++;
    }			

#if defined(FULL_VERBOSE) && not(defined(ONLY_RESULT))
    printf("\n\n----> Re'capitulatif avant mise à jour :\npPopCourante contient les individus :\n");
    for(i=0;i<nTAILLE_POP+nOFFSPRINGSIZE;i++)
      printf("%p, ",pPopCourante[i]);
			

    printf("\npNouvellePop contient les individus (dont les %d premiers sont bons) :\n",nTailleNouvellePop);
    for( i=0;i<nTAILLE_POP+nOFFSPRINGSIZE;i++)
      printf("%p, ",pNouvellePop[i]);
#endif	


				
    //delete the contant of the current population, i.e. indiviudals that have not been selected by replacement
    for (int j=0;j<nTaillePopCourante;j++) {
      delete pPopCourante[j];
      pPopCourante[j] = NULL;
    }
				
    // Et maintenant, suprême astuce, on e'change les populations !
    // Go to the next population, swap populations
    pTemp=pPopCourante; pPopCourante=pPopParents=pNouvellePop;pNouvellePop=pTemp;
    pPopEnfants=&(pPopCourante[nTAILLE_POP]);
	
#ifndef ONLY_RESULT			
    printf("PopCourante contient les individus (dont les %d premiers sont bons) :\n",nTailleNouvellePop);
    for( i=0;i<nTAILLE_POP;i++)
      printf("%s \n",pPopCourante[i]->toString().c_str());				
    printf("\n\n ON EST REPARTIS POUR UN TOUR !!! \n\n");
#endif
    // et on remet les compteurs à ze'ro
    nNbEnfants=0;
    generationCourante++;
  }

  size_t bestIndiv = 0;


  // show complete popualation and find the best individual
  for(size_t i = 0 ; i<nTAILLE_POP ; i++){
#ifndef ONLY_RESULT			
    printf("%s\n", pPopCourante[i]->toString().c_str());
#endif
#if \MINIMAXI
    if( pPopCourante[i]->nFitness > pPopCourante[bestIndiv]->nFitness )
      bestIndiv = i;
#else
    if( pPopCourante[i]->nFitness < pPopCourante[bestIndiv]->nFitness )
      bestIndiv = i;
#endif
  }

#ifndef ONLY_RESULT			
  fprintf(stdout,"mutation : %d\n",mutationOccured);
  fprintf(stdout,"Best individual is %s \n",pPopCourante[bestIndiv]->toString().c_str());
#endif
  
  returnedFitness = pPopCourante[bestIndiv]->nFitness;

  // free all internal structures
  for(size_t i = 0 ; i<nTAILLE_POP ; i++) delete pPopCourante[i];
  
  free(offspringGenomes);
  free(parentGenomes);
  return 0;
}


int main(int argc, char** argv){

#ifdef TOTAL_TIMING
  total_time.tv_sec = 0;
  total_time.tv_usec = 0;
#endif

#ifdef MEMCPY_TIMING
  total_memcopy_time.tv_sec = 0;
  total_memcopy_time.tv_usec = 0;
#endif


#ifdef DATAMOTION_TIMING
  data_motion_t.tv_sec = 0;
  data_motion_t.tv_usec = 0;
#endif

//   memcpy_t.tv_sec = 0;
//   memcpy_t.tv_usec = 0;

#ifdef KRNL_TIMING
  krnl_t.tv_sec = 0;
  krnl_t.tv_usec = 0;
#endif

#ifdef CPUCOMPUTE_TIMING
  cpu_compute_time.tv_sec = 0;
  cpu_compute_time.tv_usec = 0;
#endif

  int nb_run = 1;
  optrega(&fPMut,OPT_FLOAT,'\0',"fPMut","fPMut");
  optrega(&fPCross,OPT_FLOAT,'\0',"fPCross","fPCross");
  optrega(&bElitisme,OPT_INT,'\0',"bElitisme","bElitisme");
  //optrega(&bGPGPU,OPT_BOOL,'\0',"bGPGPU","bGPGPU");
  optrega(&nTAILLE_POP,OPT_INT,'p',"nTAILLE_POP","nTAILLE_POP");
  optrega(&nOFFSPRINGSIZE,OPT_INT,'o',"nOFFSPRINGSIZE","nOFFSPRINGSIZE");
  optrega(&nNB_GENERATION,OPT_INT,'\0',"nNB_GENERATION","nNB_GENERATION");
  optrega(&nb_run,OPT_INT,'r',"nb_run","nb of run");

  optMain(mainLoop);
  optDisableMenu();
  opt(&argc,&argv);
  opt_free();

#ifndef ONLY_RESULT
  showInfo();
#endif
  
  AESAEInitFunction(argc,argv);
  fprintf(stdout,"evaluation mode is : ");

  fprintf(stdout,"number of run : %d\n",nb_run);
  fprintf(stdout,"population size : %d\n",nTAILLE_POP);
  fprintf(stdout,"offspring population size : %d\n",nOFFSPRINGSIZE);
  fprintf(stdout,"number of generation : %d\n",nNB_GENERATION);


  float* bestFitness = new float[nb_run];
  float xb = 0;
  float pi = 1./nb_run;
  float sigma = 0;
  int status;
#ifdef TOTAL_TIMING
  DECLARE_TIME(tmp);
#endif
  // run nb_run time the GA
  for( size_t i=0 ; i<nb_run ; i++ ){
#ifdef TOTAL_TIMING
    TIME_ST(tmp);
#endif

    status = mainLoop(argc,argv);
#ifdef TOTAL_TIMING
    TIME_END(tmp);
#endif
    if( status != 0){
      fprintf(stderr,"GA doesn't finish normaly\n");
      return -1;
    }
    else{
      bestFitness[i] = returnedFitness;
#ifndef MINIMAL_VERBOSE
      //fprintf(stdout,"best fitness for %d run : %f\n",i,bestFitness[i]);
      //SHOW_TIME(tmp);
#endif
      xb += returnedFitness*pi;
#ifdef TOTAL_TIMING
      timersub(&tmp_end,&tmp_beg,&tmp_res);
      timeradd(&total_time,&tmp_res,&total_time);
#endif
    }
  }

  // compute the mean time
#ifdef TOTAL_TIMING
  double time_usec = total_time.tv_usec + total_time.tv_sec*1000000;
  time_usec /= nb_run;
  total_time.tv_sec = time_usec/1000000;
  total_time.tv_usec = time_usec - total_time.tv_sec*1000000;
#endif
  


  for( size_t i=0 ; i<nb_run ; i++ )
    sigma += pi*pow(bestFitness[i],2);

  sigma-=pow(xb,2);
  sigma = sqrt(sigma);


  fprintf(stdout,"Mean best fitness : %f\n",xb);
  fprintf(stdout,"Standard deviation : %f\n",sigma);


#ifdef TOTAL_TIMING
  printf("mean time : %d.%06d\n",total_time.tv_sec,total_time.tv_usec);
#endif
#ifdef DATAMOTION_TIMING
  printf("total_data_motion_time : %d.%06d\n",data_motion_t.tv_sec,data_motion_t.tv_usec);
#endif

#ifdef MEMCPY_TIMING  
  printf("total_memcpy_time : %d.%06d\n",memcpy_t.tv_sec,memcpy_t.tv_usec);
#endif

#ifdef KRNL_TIMING
  printf("total_krnl_time : %d.%06d\n",krnl_t.tv_sec,krnl_t.tv_usec);
#endif

#ifdef CPUCOMPUTE_TIMING
  printf("cpu_compute_time : %d.%06d\n",cpu_compute_time.tv_sec,cpu_compute_time.tv_usec);
#endif
 
  return 0;
}



\ANALYSE_PARAMETERS


\START_USER_FUN_H_TPL#ifndef USER_FUNC
#define USER_FUNC

//INSERT_USER_DECLARATIONS
\INSERT_USER_DECLARATIONS

//INSERT_USER_FUNCTIONS
\INSERT_USER_FUNCTIONS
#endif



\START_GPU_INDIVIDUAL_H_TPL// -*- mode: c++; c-indent-level: 2; c++-member-init-indent: 8; comment-column: 35; -*-
//
// (The above line is useful in Emacs-like editors)
//
//****************************************
//                                         
//  EASEAGenome.h
//                                         
//  C++ file generated by AESAE-EO v0.7b
//                                         
//****************************************
//

\ANALYSE_USER_CLASSES
#ifndef CINDIVIDU_HPP
#define CINDIVIDU_HPP

#include <stdlib.h>
//#include <iostream>
#include <sstream>
#include "tool/tool.h"
#include "EASEAUserFunc.h"

using namespace std;

//INSERT_USER_CLASSES
\INSERT_USER_CLASSES


class EASEAGenome {
public:


  EASEAGenome(){
    \GENOME_CTOR 
  }

  EASEAGenome(const EASEAGenome & arg){
    \GENOME_CTOR
    copy(arg);
  }

  virtual ~EASEAGenome(){
    \GENOME_DTOR 
  }

  virtual string className() const { return "EASEAGenome"; }

  EASEAGenome& operator=(const EASEAGenome & arg){
    copy(arg); 
    return *this;
  }
  void copy(const EASEAGenome& genome){
    if(&genome != this){
      \GENOME_DTOR
      \COPY_CTOR  
    }
  }
  bool operator==(const EASEAGenome & genome) const{
    \EQUAL
    return true;
  }
  bool operator!=(const EASEAGenome & genome) const {
    return !(*this==genome);
  }
  void readFrom(istream& is){
    \READ
  }


 
  //private:         // put all data here - no privacy in EASEA
  // START Private data of an EASEAGenome object
  bool invalid;
  \INSERT_GENOME
  // END   Private data of an EASEAGenome object
};


class CIndividu{
public:

  CIndividu(char* gpuBuffer){
    //INSERT_INITIALISRE
    \INSERT_INITIALISER

    if(gpuBuffer) memcpy(gpuBuffer,&(this->genome),sizeof(EASEAGenome));
  }

  CIndividu(const CIndividu *ind, char* gpuBuffer){
    this->genome.copy(ind->genome);
    if(gpuBuffer) memcpy(gpuBuffer,&(this->genome),sizeof(EASEAGenome));
  }

  ~CIndividu(){
    //GENOME_DTOR
    \GENOME_DTOR
  }

  float evaluation(){
    //INSERT_EVALUATOR
    EASEAGenome* genome = &(this->genome);
    \INSERT_EVALUATOR
  }
  CIndividu* croisement(const CIndividu* i1,char* gpuBuffer)const{
    CIndividu* child1 = new CIndividu(this,NULL);
    CIndividu* child2 = new CIndividu(i1,NULL);
    const CIndividu* parent1 = this;
    const CIndividu* parent2 = i1;
    //INSERT_CROSSOVER
    \INSERT_CROSSOVER
      ;

    if(gpuBuffer){
#ifdef MEMCPY_TIMING
      DECLARE_TIME(tmp);
      TIME_ST(tmp);
#endif
      memcpy(gpuBuffer,&(child1->genome),sizeof(EASEAGenome));
#ifdef MEMCPY_TIMING
      TIME_END(tmp);
      timersub(&tmp_end,&tmp_beg,&tmp_res);	    
      timeradd(&tmp_res,&total_memcopy_time,&total_memcopy_time);
#endif
    }

    free(child2);
    return child1;
  }

  bool mutation(float fPMut, char* gpuBuffer){
    //    if(randomLoc(0,1)<fPMut){
    //INSERT_MUTATOR
    \INSERT_MUTATOR
	//    }
    return false;
  }


  std::string toString(){
    if(this != NULL) {
    std::ostringstream cout;    
    //INSERT_DISPLAY
    \INSERT_DISPLAY
      
    cout << " fitness : " << nFitness;
    cout << " addr : " << this;
    cout << endl;
    return cout.str();
    }
    return string();
  }

    void printOn(ostream& os) const{
    \INSERT_DISPLAY
    \WRITE
  }

  void setFitness(float f){ this->nFitness = f;}

  float nFitness; // a transformer en float     
  EASEAGenome genome;
};

void showPopulationBooleanArray(char* population,size_t genSize, size_t popSize){
  size_t i,j;

  for( i=0; i<popSize ; i++ ){
    for( j=0 ; j<genSize ; j++){
      printf( " %d |", population[i*genSize+j]);
    }
    printf( "\n");
  }
}



void showFitnessArray(float* fitnesses, size_t popSize){
  size_t i;

  for(  i=0; i<popSize ; i++ ){
    printf("Fitness of %d is %f\n", i, fitnesses[i]);
  }
}

#endif


\START_EO_MAKEFILE_TPL
NVCC = nvcc
CPPC = nvcc
CC = g++


CFLAGS = -g -I/home/maitre/pfx/opt/include 
NVCCFLAGS = $(CFLAGS) --ptxas-options=-v #--use_fast_math # --device-emulation
CPPFLAGS = $(CFLAGS) -I/usr/local/cuda/include

HDR= $(wildcard *.h)

all:EASEA.out


EASEA.out: tool/tool.o EASEA.o
				$(NVCC) -o $@ $^ $(LDFLAGS) $(NVCCFLAGS) /home/maitre/pfx/opt/lib/libopt.a $(EXTFLAGS)

tool/%.o:tool/%.c tool/%.h
			    $(CC) -c -o $@ $< $(CFLAGS)
					      
%.o:%.cpp $(HDR)
			    $(CPPC) -c -o $@ $< $(CPPFLAGS)

%.o:%.cu $(HDR)
			    $(NVCC) -c -o $@ $< $(NVCCFLAGS) $(EXTFLAGS)

clean:
			    rm *.o EASEA.out
 
\TEMPLATE_END
