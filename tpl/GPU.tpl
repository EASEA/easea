\TEMPLATE_START// -*- mode: c++; c-indent-level: 2; c++-member-init-indent: 8; comment-column: 35; -*-
//
// (The above line is useful in Emacs-like editors)
//
//****************************************
//                                         
//  EASEA.cpp
//                                         
//  C++ file generated by AESAE-CUDA v0.9a
//                                         
//****************************************


#define GPU_BUFFER_POS(buffer,index) (buffer+sizeof(EASEAGenome)*index)
\ANALYSE_PARAMETERS
//#define ONLY_RESULT
#define MINIMAL_VERBOSE
#define MARGIN 5         // margin between cpu and gpu evaluation (only in mixed mode)
//#define MARGIN_ERROR   // if defined margin margin errors are fatal
//#define FULL_VERBOSE

#include <unistd.h>
#include <stdio.h>
#include "tool/tool.h"
#define TIMING
#include "tool/timing.h"
#include <opt.h>
#include <float.h>

#define PRESSION_SELECTION \SELECT_PRM
#define PRESSION_REPLACEMENT \RED_FINAL_PRM

#include "EASEAUserFunc.h"
#include "EASEAIndividual.h"  //Generated individual
#include "EASEAGPUEval.h"     //Generated header for gpu evaluation


//**************************************************
// 
//     At exec time variables 
//     and default values
//
//**************************************************
float fPMut=\MUT_PROB;
float fPCross=\XOVER_PROB; 

int bElitisme=1;
bool bGPGPU = true;

size_t nTAILLE_POP = \POP_SIZE;
size_t nOFFSPRINGSIZE = \OFF_SIZE;
size_t nNB_GENERATION = \NB_GEN;




//INSERT_INITIALISATION_FUNCTION 
\INSERT_INITIALISATION_FUNCTION 



// debug evaluation function
// this function does an evaluation on gpu and on cpu
// compares values between both evaluations
// and warn user (progammer) if a difference exists
// (or return a false value if margin_error is defined)

int
DEBUG_evalPopulation(char* parentGenomes, CIndividu** pPopParents, size_t popSize){
  int i;
  int ret = true;
  float* results = launch_krnl(popSize,parentGenomes);
  for (i=0;i<popSize;i++){
    pPopParents[i]->evaluation();
    if( (results[i] != pPopParents[i]->nFitness) && (pPopParents[i]->nFitness != 0) ){
      float percentError = ((results[i]-pPopParents[i]->nFitness)/pPopParents[i]->nFitness)*100;

#ifdef FULL_VERBOSE
      fprintf(stderr,"****ERROR*** %f != %f \n",results[i], pPopParents[i]->nFitness);
      fprintf(stderr,"****ERROR*** %f\n", percentError);
#endif
      

      // error control
      if( percentError > MARGIN ){
#ifdef MARGIN_ERROR
	fprintf( stderr , "****ERROR*** Error is greather than %d% --> %d\n",MARGIN,percentError);
	ret = false;
#else
	fprintf( stderr , "****WARNING*** Error is greather than %d% --> %.2f%\n",MARGIN,percentError);
#endif
      }
    }
  }
  return ret;
}


//static inline size_t tournoi(CIndividu** population, size_t popSize, size_t pression){
size_t tournoi(CIndividu** population, size_t popSize, size_t pression){
  size_t meilleurIndividu = 0;
  float meilleurFitness;
  if( \MINIMAXI )
    meilleurFitness = -FLT_MAX;
  else
    meilleurFitness = FLT_MAX;

  for( size_t i = 0 ; i<pression ; i++ ){
    size_t index = getRandomIntMax(popSize);
    //fprintf(stderr,"random selected index : %d  addr : % p fitness : %f \n",index, population[index], population[index]->nFitness);
#if \MINIMAXI
      if(population[index]->nFitness > meilleurFitness){
	meilleurFitness = population[index]->nFitness;
	meilleurIndividu = index;
      }
#else
      if(population[index]->nFitness < meilleurFitness){
	meilleurFitness = population[index]->nFitness;
	meilleurIndividu = index;
	
      }
#endif
  }
#ifdef FULL_VERBOSE
  fprintf(stderr,"meilleurIndividu %d\n",meilleurIndividu);
#endif
  return meilleurIndividu;
}



CIndividu* selection(CIndividu** population, size_t popSize){
  size_t meilleurIndividu = tournoi(population,popSize,PRESSION_SELECTION);
  return population[meilleurIndividu];
}


int compareIndividuals(const void* a, const void* b){
  const CIndividu* i1 = *(const CIndividu**)a;
  const CIndividu* i2 = *(const CIndividu**)b;
  return (((CIndividu*)i2)->nFitness - ((CIndividu*)i1)->nFitness);
}


void sortPopulation(CIndividu** population, size_t popSize){
  
  qsort(population,popSize,sizeof(CIndividu*),compareIndividuals);

}

CIndividu* remplacement(CIndividu** population, size_t popSize){
  size_t meilleurIndividu = tournoi(population,popSize,PRESSION_REPLACEMENT);
  //size_t meilleurIndividu = 0;
  CIndividu* selected = population[meilleurIndividu];

  //suppression de l'individu selectionne de la population courante
  population[meilleurIndividu] = population[popSize-1];
  return selected;
}




void gpuEvaluation(char* parentGenomes,CIndividu** pPopParents,size_t popSize){
  // compute fitness for all initial population on gpu
  float* results = launch_krnl(popSize,parentGenomes);
  //write fitness in corresponding individuals
  for (size_t i=0;i<popSize;i++){
    //printf("%p %f\n",pPopParents[i],results[i]);
    pPopParents[i]->setFitness(results[i]);
  }
  delete[] results;
}


float returnedFitness;
int mainLoop(int argc,char** argv){
	
	
  /// declarations
	
  //FILE *fpFichierSauvegarde;
  CIndividu *tPop1[nTAILLE_POP+nOFFSPRINGSIZE]; 
  CIndividu *tPop2[nTAILLE_POP+nOFFSPRINGSIZE];
  CIndividu **pTemp;
	
  CIndividu **pPopCourante=(CIndividu **) tPop1;
  CIndividu **pNouvellePop=(CIndividu **) tPop2;
	
  CIndividu **pPopParents=pPopCourante; // Pointeur sur la population de parents
  CIndividu **pPopEnfants=&(pPopCourante[nTAILLE_POP]); // Pointeur sur
  char* parentGenomes = (char*)malloc(sizeof(EASEAGenome)*nTAILLE_POP);
  char* offspringGenomes = (char*)malloc(sizeof(EASEAGenome)*nOFFSPRINGSIZE);

  int i,nNbEnfants=0,nTailleNouvellePop=0,nTaillePopCourante=0;
  size_t generationCourante = 0;
	
	
#ifndef ONLY_RESULT
  printf( "\n----> Cre'ation de la population : \n");
#endif
	
  // Cre'ation et initialisation de la population
  for (i=0;i<nTAILLE_POP;i++) {
    pPopParents[i]=new CIndividu(GPU_BUFFER_POS(parentGenomes,i));
#ifndef ONLY_RESULT
    printf("\npPopParents[%d]=%p\n",i,pPopParents[i]); 
#endif

  }


  // initialize pseudo-random generator to current time
  srand(time(0));
  
  for( i=nTAILLE_POP; i<nOFFSPRINGSIZE ; i++)
    pPopEnfants[i] = NULL;
  
  for( i=0 ; i<nTAILLE_POP+nOFFSPRINGSIZE; i++)
    pNouvellePop[i] = NULL;

#ifndef ONLY_RESULT
  printf("\n----> Evaluation de la population \n");
#endif
	
  // Evaluation pour cre'er une population de parents
  
//   if( bGPGPU ){
//     gpuEvaluation(parentGenomes,pPopParents,nTAILLE_POP);
//   }
//   else
//     for (i=0;i<nTAILLE_POP;i++)
//       pPopParents[i]->evaluation();

  if(!DEBUG_evalPopulation(parentGenomes,pPopParents,nTAILLE_POP))
    return -1;
  

#ifndef ONLY_RESULT
  for (i=0;i<nTAILLE_POP;i++)
    printf("%s\n",pPopParents[i]->toString().c_str());
#endif
  
  sortPopulation(pPopParents,nTAILLE_POP);
  fprintf(stdout,"sorted population \n");

#ifndef ONLY_RESULT
  for (i=0;i<nTAILLE_POP;i++)
    printf("%s\n",pPopParents[i]->toString().c_str());
#endif
  fprintf(stdout,"sorted population \n");

  // Boucle e'volutionnaire
  while( generationCourante < nNB_GENERATION ){


#if defined(FULL_VERBOSE) && !defined(ONLY_RESULT)
    printf("La PopParents contient :\n");
    for(i=0;i<nTAILLE_POP;i++)
      printf("%p, ",pPopParents[i]);

    printf("\n");
    printf("\n");
    printf("-----------------------------------------------------------------");
    printf("\n");
#endif

		
    while (nNbEnfants<nOFFSPRINGSIZE){   // boucle sur la taille des enfants			
      if (randomLoc(0,1)<fPCross) { // ope'rateur binaire (croisement) 

#if defined(MINIMAL_VERBOSE) && !defined(ONLY_RESULT)
	printf("\nCroisement : ");
#endif
				
	CIndividu *i1,*i2;
	i1=selection(pPopParents,nTAILLE_POP);
				
	do{
	  i2=selection(pPopParents,nTAILLE_POP);    // 
	} while (i2 ==i1); // Moui, c'est pas oblige' mais pourquoi pas...
	//rajouter un and afin de  stopper en cas de convergence
				
	if (randomLoc(0,1)<0.5) // micro-subtilite'... ;-)
	  pPopEnfants[nNbEnfants]=i1->croisement(i2,NULL);  
	else  
	  pPopEnfants[nNbEnfants]=i2->croisement(i1,NULL);

        #if defined(MINIMAL_VERBOSE) && !defined(ONLY_RESULT)
	printf("%p + %p = %p\n",i1,i2,pPopEnfants[nNbEnfants]);
        #endif

      }
      else { // ope'rateur unaire (clonage)
	CIndividu *i1;
				
	i1=selection(pPopParents,nTAILLE_POP);  //Il faut e'crire la se'lection
	//pPopEnfants[nNbEnfants]=new CIndividu(i1,GPU_BUFFER_POS(offspringGenomes,nNbEnfants));
	pPopEnfants[nNbEnfants]=new CIndividu(i1,NULL);


#if defined(FULL_VERBOSE) && !defined(ONLY_RESULT)
	printf("Clonage: %p clone' en %p\n",i1,pPopEnfants[nNbEnfants]);
#endif
      }
      
      //printf("\nMutation de %p\n",pPopEnfants[nNbEnfants]);      
      pPopEnfants[nNbEnfants]->mutation(fPMut,GPU_BUFFER_POS(offspringGenomes,nNbEnfants)); // mutation.
      memcpy(GPU_BUFFER_POS(offspringGenomes,nNbEnfants),&(pPopEnfants[nNbEnfants]->genome),sizeof(EASEAGenome));

      nNbEnfants++;
    }
    // Bon, et bien on est maintenant au complet (parents + enfants)
    // Il faut maintenant e'valuer tous les enfants
		

    #if defined(FULL_VERBOSE) && !defined(ONLY_RESULT)
    printf("\n");
    printf("-----------------------------------------------------------------");
    printf("\n");
    #endif


//     if( bGPGPU )
//       gpuEvaluation(offspringGenomes,pPopEnfants,nOFFSPRINGSIZE);
//     else
//       for (i=0;i<nOFFSPRINGSIZE;i++)		
// 	pPopEnfants[i]->evaluation();

    if(!DEBUG_evalPopulation(offspringGenomes,pPopEnfants,nOFFSPRINGSIZE))
      return -1;
      


    #if defined(MINIMAL_VERBOSE) && !defined(ONLY_RESULT)
    for (i=0;i<nOFFSPRINGSIZE;i++)
      printf("%s\n",pPopEnfants[i]->toString().c_str());
    printf("\n\n");
    #endif
		

    // Il faut maintenant remplir la nouvelle population et on raisonne
    // maintenant en population globale parents+enfants
		
    nTaillePopCourante=nTAILLE_POP+nOFFSPRINGSIZE;
    nTailleNouvellePop=0;

    #ifndef ONLY_RESULT		
    printf("La PopCourante contient :\n");
    for(i=0;i<nTaillePopCourante;i++)
      printf("%p (%f), ",pPopParents[i],pPopParents[i]->nFitness);
    printf("\n");
    #endif
		
    // Si on de'cide qu'il y a de l'e'litisme, on commence par un e'litisme mou
		
    if (bElitisme){
			
      int iMeilleur=0;
      for (i=1;i<nTaillePopCourante;i++)

        #if \MINIMAXI
	  if (pPopCourante[i]->nFitness>pPopCourante[iMeilleur]->nFitness)
	    iMeilleur=i;
        #else
	  if (pPopCourante[i]->nFitness<pPopCourante[iMeilleur]->nFitness)
	    iMeilleur=i;
        #endif 
				
      pNouvellePop[0]=pPopCourante[iMeilleur];
			
      #ifndef ONLY_RESULT
      printf("----> Elitisme : on recopie %p dans la population d'enfants\n",pNouvellePop[0]);
      #endif
				
      // Maintenant, on supprime de la population courante l'individu
      // qui a e'te' tranfe're' dans la nouvelle population
      pPopCourante[iMeilleur]=pPopCourante[nTaillePopCourante-1];
      nTaillePopCourante--; nTailleNouvellePop++;
    }
		
    #ifndef ONLY_RESULT
    printf("----> Remplacement\n");
    printf("----> Re'capitulatif avant Remplacement:\npPopCourante contient les individus :\n");
    for( i=0;i<nTaillePopCourante;i++)
      printf("%s\n",pPopCourante[i]->toString().c_str());
    #endif
		
    
    // remplacement part
    while(nTailleNouvellePop<nTAILLE_POP){
      pNouvellePop[nTailleNouvellePop]=remplacement(pPopCourante,nTaillePopCourante);

      #if defined(MINIMAL_VERBOSE) && !defined(ONLY_RESULT)
      printf("%p est e'lu\n\n",pNouvellePop[nTailleNouvellePop]);
      #endif

      nTaillePopCourante--; 
      nTailleNouvellePop++;
    }			

#if defined(FULL_VERBOSE) && not(defined(ONLY_RESULT))
    printf("\n\n----> Re'capitulatif avant mise à jour :\npPopCourante contient les individus :\n");
    for(i=0;i<nTAILLE_POP+nOFFSPRINGSIZE;i++)
      printf("%p, ",pPopCourante[i]);
			

    printf("\npNouvellePop contient les individus (dont les %d premiers sont bons) :\n",nTailleNouvellePop);
    for( i=0;i<nTAILLE_POP+nOFFSPRINGSIZE;i++)
      printf("%p, ",pNouvellePop[i]);
#endif	


				
    //delete the contant of the current population, i.e. indiviudals that have not been selected by replacement
    for (int j=0;j<nTaillePopCourante;j++) {
      delete pPopCourante[j];
      pPopCourante[j] = NULL;
    }
				
    // Et maintenant, suprême astuce, on e'change les populations !
    // Go to the next population, swap populations
    pTemp=pPopCourante; pPopCourante=pPopParents=pNouvellePop;pNouvellePop=pTemp;
    pPopEnfants=&(pPopCourante[nTAILLE_POP]);
	
#ifndef ONLY_RESULT			
    printf("PopCourante contient les individus (dont les %d premiers sont bons) :\n",nTailleNouvellePop);
    for( i=0;i<nTAILLE_POP;i++)
      printf("%s \n",pPopCourante[i]->toString().c_str());				
    printf("\n\n ON EST REPARTIS POUR UN TOUR !!! \n\n");
#endif
    // et on remet les compteurs à ze'ro
    nNbEnfants=0;
    generationCourante++;
  }

  size_t bestIndiv = 0;


  // show complete popualation and find the best individual
  for(size_t i = 0 ; i<nTAILLE_POP ; i++){
#ifndef ONLY_RESULT			
    printf("%s\n", pPopCourante[i]->toString().c_str());
#endif
#if \MINIMAXI
    if( pPopCourante[i]->nFitness > pPopCourante[bestIndiv]->nFitness )
      bestIndiv = i;
#else
    if( pPopCourante[i]->nFitness < pPopCourante[bestIndiv]->nFitness )
      bestIndiv = i;
#endif
  }

#ifndef ONLY_RESULT			
  fprintf(stdout,"mutation : %d\n",mutationOccured);
  fprintf(stdout,"Best individual is %s \n",pPopCourante[bestIndiv]->toString().c_str());
#endif
  
  returnedFitness = pPopCourante[bestIndiv]->nFitness;

  // free all internal structures
  for(size_t i = 0 ; i<nTAILLE_POP ; i++) delete pPopCourante[i];
  
  free(offspringGenomes);
  free(parentGenomes);
  return 0;
}


int main(int argc, char** argv){
  int nb_run = 1;
  optrega(&fPMut,OPT_FLOAT,'\0',"fPMut","fPMut");
  optrega(&fPCross,OPT_FLOAT,'\0',"fPCross","fPCross");
  optrega(&bElitisme,OPT_INT,'\0',"bElitisme","bElitisme");
  //optrega(&bGPGPU,OPT_BOOL,'\0',"bGPGPU","bGPGPU");
  optrega(&nTAILLE_POP,OPT_INT,'\0',"nTAILLE_POP","nTAILLE_POP");
  optrega(&nOFFSPRINGSIZE,OPT_INT,'\0',"nOFFSPRINGSIZE","nOFFSPRINGSIZE");
  optrega(&nNB_GENERATION,OPT_INT,'\0',"nNB_GENERATION","nNB_GENERATION");
  optrega(&nb_run,OPT_INT,'r',"nb_run","nb of run");

  optMain(mainLoop);
  optDisableMenu();
  opt(&argc,&argv);
  opt_free();

#ifndef ONLY_RESULT
  showInfo();
#endif


  float* bestFitness = new float[nb_run];
  float xb = 0;
  float pi = 1./nb_run;
  float sigma = 0;
  int status;
  DECLARE_TIME(total);

  // run nb_run time the GA
  for( size_t i=0 ; i<nb_run ; i++ ){
    TIME_ST(total);
    status = mainLoop(argc,argv);
    TIME_END(total);
    if( status != 0){
      fprintf(stderr,"GA doesn't finish normaly\n");
      return -1;
    }
    else{
      bestFitness[i] = returnedFitness;
      fprintf(stdout,"best fitness for %d run : %f\n",i,bestFitness[i]);
      SHOW_TIME(total);
      xb += returnedFitness*pi;
    }
  }

  for( size_t i=0 ; i<nb_run ; i++ )
    sigma += pi*pow(bestFitness[i],2);

  sigma-=pow(xb,2);
  sigma = sqrt(sigma);


  fprintf(stdout,"Standard deviation : %f\n",sigma);
  fprintf(stdout,"Mean : %f\n",xb);

  return 0;
}



\ANALYSE_PARAMETERS


\START_USER_FUN_H_TPL#ifndef USER_FUNC
#define USER_FUNC

//INSERT_USER_DECLARATIONS
\INSERT_USER_DECLARATIONS

//INSERT_USER_FUNCTIONS
\INSERT_USER_FUNCTIONS
#endif



\START_GPU_INDIVIDUAL_H_TPL// -*- mode: c++; c-indent-level: 2; c++-member-init-indent: 8; comment-column: 35; -*-
//
// (The above line is useful in Emacs-like editors)
//
//****************************************
//                                         
//  EASEAGenome.h
//                                         
//  C++ file generated by AESAE-EO v0.7b
//                                         
//****************************************
//

\ANALYSE_USER_CLASSES
#ifndef CINDIVIDU_HPP
#define CINDIVIDU_HPP

#include <stdlib.h>
//#include <iostream>
#include <sstream>
#include "tool/tool.h"
#include "EASEAUserFunc.h"

using namespace std;

//INSERT_USER_CLASSES
\INSERT_USER_CLASSES


class EASEAGenome {
public:


  EASEAGenome(){
    \GENOME_CTOR 
  }

  EASEAGenome(const EASEAGenome & arg){
    \GENOME_CTOR
    copy(arg);
  }

  virtual ~EASEAGenome(){
    \GENOME_DTOR 
  }

  virtual string className() const { return "EASEAGenome"; }

  EASEAGenome& operator=(const EASEAGenome & arg){
    copy(arg); 
    return *this;
  }
  void copy(const EASEAGenome& genome){
    if(&genome != this){
      \GENOME_DTOR
      \COPY_CTOR  
    }
  }
  bool operator==(const EASEAGenome & genome) const{
    \EQUAL
    return true;
  }
  bool operator!=(const EASEAGenome & genome) const {
    return !(*this==genome);
  }
  void readFrom(istream& is){
    \READ
  }


 
  //private:         // put all data here - no privacy in EASEA
  // START Private data of an EASEAGenome object
  bool invalid;
  \INSERT_GENOME
  // END   Private data of an EASEAGenome object
};


class CIndividu{
public:

  CIndividu(char* gpuBuffer){
    //INSERT_INITIALISRE
    \INSERT_INITIALISER

    if(gpuBuffer) memcpy(gpuBuffer,&(this->genome),sizeof(EASEAGenome));
  }

  CIndividu(const CIndividu *ind, char* gpuBuffer){
    this->genome.copy(ind->genome);
    if(gpuBuffer) memcpy(gpuBuffer,&(this->genome),sizeof(EASEAGenome));
  }

  ~CIndividu(){
    //GENOME_DTOR
    \GENOME_DTOR
  }

  float evaluation(){
    //INSERT_EVALUATOR
    EASEAGenome* genome = &(this->genome);
    \INSERT_EVALUATOR
  }
  CIndividu* croisement(const CIndividu* i1,char* gpuBuffer)const{
    CIndividu* child1 = new CIndividu(this,NULL);
    CIndividu* child2 = new CIndividu(i1,NULL);
    const CIndividu* parent1 = this;
    const CIndividu* parent2 = i1;
    //INSERT_CROSSOVER
    \INSERT_CROSSOVER
      ;
    if(gpuBuffer)memcpy(gpuBuffer,&(child1->genome),sizeof(EASEAGenome));
    free(child2);
    return child1;
  }

  bool mutation(float fPMut, char* gpuBuffer){
    //    if(randomLoc(0,1)<fPMut){
    //INSERT_MUTATOR
    \INSERT_MUTATOR
	//    }
    return false;
  }

  float nFitness; // a transformer en float 
  std::string toString(){
    if(this != NULL) {
    std::ostringstream cout;    
    //INSERT_DISPLAY
    \INSERT_DISPLAY
      
    cout << " fitness : " << nFitness;
    cout << " addr : " << this;
    cout << endl;
    return cout.str();
    }
    return string();
  }

    void printOn(ostream& os) const{
    \INSERT_DISPLAY
    \WRITE
  }

  void setFitness(float f){ this->nFitness = f;}
    
  EASEAGenome genome;
};

void showPopulationBooleanArray(char* population,size_t genSize, size_t popSize){
  size_t i,j;

  for( i=0; i<popSize ; i++ ){
    for( j=0 ; j<genSize ; j++){
      printf( " %d |", population[i*genSize+j]);
    }
    printf( "\n");
  }
}

// void showIndiv(Generic_T_adGenome* gen){
//   int i;
//   for( i=0 ; i<501; i++ )printf("%f | ",gen->sigma[i]);
//   printf("\n");
//   for( i=0 ; i<501; i++ )printf("%f | ",gen->x[i]);
//   printf("\n");
//   printf("\n");
// }
	


// void DEBUG_show_gpu_pop(char* population,size_t genSize, size_t popSize){
//   int i;

//   for( i=0 ; i<popSize ; i++){
//     Generic_T_adGenome* gen = (Generic_T_adGenome*)GPU_BUFFER_POS(population,i);
//     showIndiv(gen);
//   }
// }


void showFitnessArray(float* fitnesses, size_t popSize){
  size_t i;

  for(  i=0; i<popSize ; i++ ){
    printf("Fitness of %d is %f\n", i, fitnesses[i]);
  }
}

#endif

\START_GPU_EVAL_H_TPL
//START_GPU_EVAL_H_TPL
#ifndef GPU_EVA_H_TPL
#define GPU_EVA_H_TPL

#define DEBUG_KRNL
#include "tool/basetype.h"
#include "tool/tool.h"
#include "tool/timing.h"
#include "tool/debug.h"
#include "EASEAUserFunc.h"
#include "EASEAIndividual.h"
#include <iostream>
#include <assert.h>

using namespace std;



#define MAX_THREAD_NUM 512
#define NB_MP 8



#define NB_MP 8
#define MAX_BLOCK_SIZE 512


bool
repartition(size_t popSize, size_t* nbBlock, size_t* nbThreadPB, size_t* nbThreadLB, 
	    size_t nbMP, size_t maxBlockSize){
  
  (*nbThreadLB) = 0;
  
  if( ((float)popSize / (float)nbMP) <= maxBlockSize ){
    //la population répartie sur les MP tient dans une bloc par MP
    (*nbThreadPB) = partieEntiereSup( (float)popSize/(float)nbMP);
    (*nbBlock) = popSize/(*nbThreadPB);
    if( popSize%nbMP != 0 ){
      //on fait MP-1 block de équivalent et un plus petit
      (*nbThreadLB) = popSize - (*nbThreadPB)*(*nbBlock);
    }
  }
  else{
    //la population est trop grande pour etre répartie sur les MP
    //directement
    (*nbBlock) = partieEntiereSup( (float)popSize/((float)maxBlockSize*8));
    (*nbBlock) *=8;
    (*nbThreadPB) = popSize/(*nbBlock);
    if( popSize%maxBlockSize!=0){
      (*nbThreadLB) = popSize - (*nbThreadPB)*(*nbBlock);
      
      // Le rest est trop grand pour etre placé dans un seul block (c'est possible uniquement qd 
      // le nombre de block dépasse maxBlockSize 
      while( (*nbThreadLB) > maxBlockSize ){
	//on augmente le nombre de blocs principaux jusqu'à ce que nbthreadLB retombe en dessous de maxBlockSize
	(*nbBlock) += nbMP;
 	(*nbThreadPB) = popSize/(*nbBlock);
	(*nbThreadLB) = popSize - (*nbThreadPB)*(*nbBlock);
      }
    }
  }
  
  if((((*nbBlock)*(*nbThreadPB) + (*nbThreadLB))  == popSize) 
     && ((*nbThreadLB) <= maxBlockSize) && ((*nbThreadPB) <= maxBlockSize))
    return true;
  else 
    return false;
}




__host__ void showInfo(){
  int devCount,i;
  cudaError_t lastError;
  struct cudaDeviceProp cdp;
  
  CDC(lastError,"cudaGetDeviceCount",cudaGetDeviceCount(&devCount));
  
  printf("Number of device : %d\n",devCount);
  for( i=0 ; i<devCount ; i++ ){
    CDC(lastError,"cudaGetDeviceProperties",cudaGetDeviceProperties(&cdp,i));
    printf("Name : %s\n",cdp.name);
    printf("TotalGlobalMem %d\n",cdp.totalGlobalMem);
    printf("SharedMemPerBlock %d\n",cdp.sharedMemPerBlock);
    printf("regsPerBlock %d\n",cdp.regsPerBlock);
    printf("warpSize %d\n",cdp.warpSize);
    printf("memPitch %d\n",cdp.memPitch);
    printf("maxThreadsPerBlock %d\n",cdp.maxThreadsPerBlock);
    
    printf("maxThreadsDim.x %d\n",cdp.maxThreadsDim[0]);
    printf("maxThreadsDim.y %d\n",cdp.maxThreadsDim[1]);
    printf("maxThreadsDim.z %d\n",cdp.maxThreadsDim[2]);
    
    printf("maxGridSize.x %d\n",cdp.maxGridSize[0]);
    printf("maxGridSize.y %d\n",cdp.maxGridSize[1]);
    printf("maxGridSize.z %d\n",cdp.maxGridSize[2]);
    
    printf("totalConstMem %d\n",cdp.totalConstMem);
    printf("major %d\n",cdp.major);
    printf("minor %d\n",cdp.minor);
    printf("clockRate %d\n",cdp.clockRate);
    printf("textureAlignment %d\n",cdp.textureAlignment);
    printf("deviceOverlap %d\n",cdp.deviceOverlap);
    printf("multiProcessorCount %d\n",cdp.multiProcessorCount);
  }
}


__host__ __device__ FITNESS_TYPE gpuEvaluate(BOOLEAN_EA* rawGenome){


  EASEAGenome* genome = (EASEAGenome*)rawGenome;

  //INSERT_EVALUATOR
  \INSERT_EVALUATOR
}


__global__ void cudaEvaluatePopulationSM(BOOLEAN_EA* d_population, float* d_fitnesses, size_t nbThreadLB){

  extern __shared__ BOOLEAN_EA s_data[];
  size_t id = blockDim.x*blockIdx.x+threadIdx.x;    
  size_t individual = id*sizeof(EASEAGenome);
  size_t i=0;


  // last block is the block which computes reminder
  if( blockIdx.x == gridDim.x-1){
    if( threadIdx.x >= nbThreadLB ) return;
  }

  //do the copy in the shared memory
  for(i=0;i<sizeof(EASEAGenome);i++) s_data[(threadIdx.x*sizeof(EASEAGenome))+i] = d_population[individual+i];
  
  
  d_fitnesses[id] = gpuEvaluate(s_data+(threadIdx.x*sizeof(EASEAGenome)));

}




__global__ void cudaEvaluatePopulation(BOOLEAN_EA* d_population, float* d_fitnesses, size_t nbThreadLB){


  size_t individual = blockDim.x*blockIdx.x*sizeof(EASEAGenome)+threadIdx.x*sizeof(EASEAGenome);
  size_t id = blockDim.x*blockIdx.x+threadIdx.x;


  // last block is the block which computes reminder
  if( blockIdx.x == gridDim.x-1){
    if( threadIdx.x >= nbThreadLB ) return;
  }
  
  d_fitnesses[id] = gpuEvaluate(d_population+(id*sizeof(EASEAGenome)));
}



float* 
launch_krnl(size_t popSize, BOOLEAN_EA* pop){
  BOOLEAN_EA* d_population;
  float* fitnessTab, * d_fitnessTab;
  cudaError_t lastError = cudaSuccess;

  size_t nbBlock,nbThreadPB,nbThreadLB;
   size_t memSize = sizeof(EASEAGenome) * popSize;
  fitnessTab = new float[popSize];

  CDC(lastError,"CudaMalloc d_population",cudaMalloc( (void**) &d_population, memSize));
  CDC(lastError,"CudaMalloc d_fitnessTab",cudaMalloc( (void**) &d_fitnessTab, popSize*sizeof(float)));
  
  

  CDC(lastError,"CudaMemCpy #1",cudaMemcpy( d_population, pop, memSize, cudaMemcpyHostToDevice));
  //cudaThreadSynchronize();
  
  //compute the repartition over MP and SP
  repartition(popSize,&nbBlock,&nbThreadPB,&nbThreadLB,NB_MP,MAX_THREAD_NUM);
  dim3 dimBlock(nbThreadPB);
  dim3 dimGrid;

  //  size_t sharedMemSize = nbThreadPB*sizeof(EASEAGenome)*sizeof(BOOLEAN_EA);

#ifndef ONLY_RESULT
  cout << "repartition -> nbBlock : " << nbBlock << " nbThreadPB : " << nbThreadPB
       << " nbThreadLB : " << nbThreadLB << endl;
#endif

  //wird things, take a look. Does the bug of repartition function become from here?
  if( nbThreadLB == 0 )
    dimGrid = dim3(nbBlock+1);
  else
    dimGrid = dim3(nbBlock+1);


  CDC(
      lastError,
      "Launch kernel",
      (cudaEvaluatePopulation<<< dimGrid, dimBlock >>>(d_population,d_fitnessTab,nbThreadLB)));
  cudaThreadSynchronize();
  
  CDC(lastError,"CudaMemCpy #2",cudaMemcpy( fitnessTab , d_fitnessTab , popSize*sizeof(float), cudaMemcpyDeviceToHost));

  CDC(lastError,"CudaFree d_population",cudaFree( (void*) d_population));
  CDC(lastError,"CudaFree d_fitnessTab",cudaFree( (void*) d_fitnessTab));

  return fitnessTab;
}
#endif

//START_EO_INITER_TPL
//START_EO_MUT_TPL
//START_EO_QUAD_XOVER_TPL
//START_EO_CONTINUE_TPL
//START_EO_PARAM_TPL
\START_EO_MAKEFILE_TPL
NVCC = nvcc
CPPC = nvcc
CC = g++


CFLAGS = -g -I/home/maitre/pfx/opt/include 
NVCCFLAGS = $(CFLAGS) #--use_fast_math #--device-emulation
CPPFLAGS = $(CFLAGS) -I/usr/local/cuda/include


LDFLAGS = -lxml2

HDR= $(wildcard *.h)

all:EASEA.out


EASEA.out: tool/tool.o EASEA.o
			    $(NVCC) -o $@ $^ $(LDFLAGS) $(NVCCFLAGS) /home/maitre/pfx/opt/lib/libopt.a 

tool/%.o:tool/%.c tool/%.h
			    $(CC) -c -o $@ $< $(CFLAGS)
					      
%.o:%.cpp $(HDR)
			    $(CPPC) -c -o $@ $< $(CPPFLAGS)

%.o:%.cu $(HDR)
			    $(NVCC) -c -o $@ $< $(NVCCFLAGS) 

clean:
			    rm *.o EASEA.out
 
\TEMPLATE_END
