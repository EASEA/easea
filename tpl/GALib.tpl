\TEMPLATE_START//********************************************
//                                         
//  EASEA.cpp
//                                         
//  C++ file generated by AESAE-GALIB Millennium Edition (v0.6)
//                                         
//********************************************

#define \OPERATING_SYSTEM
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <iostream.h>
#include <fstream.h>
#include <time.h>
#include <ga/ga.h>

#ifdef UNIX_OS
  #include <unistd.h>
  #include <values.h>
  #include "gdchart0.94b/gdc.h"
  #include "gdchart0.94b/gdchart.h"
#endif

#define MINIMISE -1
#define MAXIMISE 1
int EZ_EVALUATED_GENERATIONS=0;
int EZ_NB_EVALUATIONS=0;
clock_t   EZ_START, EZ_AVG_START, EZ_FINISH;
double EZ_LET=0; // Last Elapsed Time
double EZ_LERT=1; // Last Evaluated Remaining Time
float EZ_MUT_PROB, EZ_CROSS_PROB, EZ_REPL_PERC=0;
int EZ_NB_GEN, EZ_POP_SIZE;
double *EZ_daFITNESS;

#ifdef UNIX_OS
extern "C" out_graph( short, short, FILE *, GDC_CHART_T, int, char *[], int, float[]);
#endif

GABoolean tossCoin(float prob=.5){
  return GAFlipCoin(prob);
}
GABoolean tossCoin(double prob=.5){
  return GAFlipCoin((float)prob);
}
inline int random(int b1=0, int b2=1){
  return GARandomInt(b1,b2);
}
inline double random(double b1=0, double b2=1){
  return GARandomDouble(b1,b2);
}
inline float random(float b1=0, float b2=1){
  return GARandomFloat(b1,b2);
}

\ANALYSE_PARAMETERS\INSERT_USER_DECLARATIONS

\ANALYSE_USER_CLASSES

\INSERT_USER_CLASSES

// User Genome                                          
class EASEAGenome : public GAGenome {
// Default methods for class EASEAGenome
public:
  GADefineIdentity("EASEAGenome", 251);
  static void Initializer(GAGenome&);
  static int Mutator(GAGenome&, float);
  static float Comparator(const GAGenome&, const GAGenome&);
  static float Evaluator(GAGenome&);
  static int Crossover(const GAGenome&, const GAGenome&, GAGenome*, GAGenome*);
public:
  EASEAGenome::EASEAGenome() :GAGenome(Initializer, Mutator, Comparator){
    evaluator(Evaluator); crossover(Crossover);
\GENOME_CTOR  }
  EASEAGenome(const EASEAGenome & orig) {
\GENOME_CTOR    copy(orig);
  }
  ~EASEAGenome() {
\GENOME_DTOR  }
  EASEAGenome& operator=(const EASEAGenome &);
  virtual GAGenome *clone(GAGenome::CloneMethod) const ;
  virtual void copy(const GAGenome & c);
  virtual int equal(const GAGenome& g) const;
  virtual int read(istream & is);
  virtual int write(ostream & os) const ;

\INSERT_GENOME};

EASEAGenome& EASEAGenome::operator=(const EASEAGenome & arg){ 
  copy(arg); 
  return *this;
}

void EASEAGenome::copy(const GAGenome& g) {
if(&g != this){
\GENOME_DTOR
  GAGenome::copy(g);    // copy the base class part
  EASEAGenome & genome = (EASEAGenome &)g;
\COPY_CTOR  }
}

GAGenome*EASEAGenome::clone(GAGenome::CloneMethod) const {
  return new EASEAGenome(*this);
}

int EASEAGenome::equal(const GAGenome& g) const {
  EASEAGenome& genome = (EASEAGenome&)g;
\EQUAL  return 1;
}

float EASEAGenome::Comparator(const GAGenome& g, const GAGenome& h) {
  EASEAGenome& sis = (EASEAGenome &)g;
  EASEAGenome& bro = (EASEAGenome &)h;
  int diff = 0;
\COMPARE  return (float)diff;
}         

int EASEAGenome::read(istream & is) {
\READ  return is.fail() ? 1 : 0;
}

\INSERT_USER_FUNCTIONS

int EASEAGenome::write(ostream & os) const {
\INSERT_DISPLAY
\WRITE  return os.fail() ? 1 : 0;
}

\INSERT_INITIALISATION_FUNCTION

\INSERT_INITIALISER

\INSERT_CROSSOVER

\INSERT_MUTATOR

\INSERT_EVALUATOR
\INSERT_GENERATION_FUNCTION

int main(int argc, char *argv[]){
  FILE *EZ_PRM;
  int i;

  if ( (EZ_daFITNESS = (double *) malloc(\NB_GEN * sizeof (double) )) == NULL){
    fprintf(stderr,"Not enough memory... bailing out.");
    exit (1); 
  }

#ifdef UNIX_OS
//netscape declarations and initialisations
  char EZ_Netscape[]="netscape";
  char *EZ_NetscapeParams[]={
    "netscape", 
    "-remote",
    "OpenFile /home/collet/progs/easea/EASEA.html",
    "-geometry",
    "350x500",
    NULL
};

// HTML and gdchart declarations and initialisations
      FILE *EZ_HtmlFile;
      int EZ_GDC_NbXValues;
      int EZ_GDC_Sampling=1;
      char *EZ_GDC_XLabels[51];
      float *EZ_GDC_Values;
      unsigned long EZ_GDC_Color=0x8080FF;
      FILE *EZ_GDC_OutputFile;

      GDC_BGColor   = 0xFFFFFFL;  // backgound color (white)
      GDC_LineColor = 0x000000L;  // line color      (black) 
      GDC_SetColor  = &EZ_GDC_Color;

// Creation of the html file
      if (!(EZ_HtmlFile=fopen("EASEA.html","w"))){
        fprintf(stderr,"Unable to open EASEA.html");
        exit (1); 
      }
      fprintf(EZ_HtmlFile,"<HTML> <BODY BGCOLOR=\"#000000\" TEXT=\"#FFFFFF\">");
      fprintf(EZ_HtmlFile,"Best individual/generation for <CODE>EASEA</CODE> experiment. <BR><BR><HR>");
      fprintf(EZ_HtmlFile,"<IMG BORDER=0 HSPACE=0 VSPACE=0 SRC=EASEA.gif><BR
CLEAR=\"ALL\"><BR> <HR> ");
      fprintf(EZ_HtmlFile,"Click on \"RELOAD\" while pressing the \"SHIFT\" key
to refresh the window.<BR><HR> </BODY> </HTML>");
      fclose(EZ_HtmlFile);
#endif

  GARandomSeed(0);

// Checks whether we've been given a seed to use (for testing purposes).
  for(i=1; i<argc; i++)
    if(strcmp(argv[i++],"seed") == 0)
      GARandomSeed((unsigned int)atoi(argv[i]));
\INSERT_INIT_FCT_CALL
  GA\SELECTORSelector select;
  EASEAGenome genome;
  GA\REPLACEMENTGA ga(genome);
  ga.minimaxi(\MINIMAXI);
\ELITISM  ga.populationSize(\POP_SIZE); // how many individuals in the population
  ga.nGenerations(\NB_GEN);    // number of generations to evolve
\STEADYSTATE  ga.pReplacement(\REPL_PERC);    // percentage of the population to be replaced
  ga.pMutation(\MUT_PROB);    // likelihood of mutating new offspring
  ga.pCrossover(\XOVER_PROB);   // likelihood of crossing over parents
  if (EZ_PRM=fopen("EASEA.prm","r")){
    fclose(EZ_PRM);
    ga.parameters("EASEA.prm"); // gets GALib parameters from the EASEA.prm file
  }
  ga.parameters(argc, argv); // gets GALib parameters from the command line
  EZ_POP_SIZE=ga.populationSize();
  EZ_NB_GEN=ga.nGenerations();
  if ( (EZ_daFITNESS = (double *) realloc(EZ_daFITNESS, (EZ_NB_GEN+1) * sizeof (double) )) == NULL){
    fprintf(stderr,"Not enough memory... bailing out.");
    exit (1); 
  }
  EZ_MUT_PROB=ga.pMutation();
  EZ_CROSS_PROB=ga.pCrossover();
\STEADYSTATE  EZ_REPL_PERC=ga.pReplacement()*100;
  ga.selector(select);

#ifdef UNIX_OS
  EZ_GDC_NbXValues=EZ_NB_GEN;
  while (EZ_GDC_NbXValues>50) {EZ_GDC_NbXValues/=10;EZ_GDC_Sampling*=10;}
  EZ_GDC_XLabels[0]=new char[100];
  strcpy(EZ_GDC_XLabels[0],"0");
  EZ_GDC_Values=new float[EZ_GDC_NbXValues+1];
#endif

  genome.initialize();
  EZ_daFITNESS[0]=genome.Evaluator(genome);
  cout << "Score of a generation 0 genome: " << EZ_daFITNESS[0] << "\n";
  cout << "Contents of the genome:\n" << genome << endl;

#ifdef UNIX_OS
  for (i=1;i<=EZ_GDC_NbXValues;i++){
    EZ_GDC_XLabels[i]=new char[100];
    sprintf(EZ_GDC_XLabels[i],"%d",i*EZ_GDC_Sampling+(EZ_NB_GEN-EZ_GDC_Sampling*EZ_GDC_NbXValues));
    EZ_GDC_Values[i]=(float)0;
  }
  EZ_GDC_Values[0]=(float)EZ_daFITNESS[0];
#endif

  EZ_START=clock();
  ga.initialize();       
  fprintf(stderr,"Estimated Remaining Time:           ");
  EZ_AVG_START=clock()+CLOCKS_PER_SEC/2; // to take the overhead into account
  do{\INSERT_GEN_FCT_CALL    ga.step();
    EZ_EVALUATED_GENERATIONS++;
    EZ_daFITNESS[EZ_EVALUATED_GENERATIONS]=(ga.statistics().bestIndividual()).evaluate(); 
    EZ_FINISH=clock();
    if ((double)(EZ_FINISH-EZ_AVG_START)-EZ_LET > CLOCKS_PER_SEC){
      for (i=0;i<log10(EZ_LERT);i++) fprintf(stderr,"\b");
      EZ_LET=(double)(EZ_FINISH-EZ_AVG_START) ;
      EZ_LERT=(EZ_LET*(ga.nGenerations()-EZ_EVALUATED_GENERATIONS)/EZ_EVALUATED_GENERATIONS)/CLOCKS_PER_SEC;
      fprintf(stderr,"\b\b\b\b\b\b\b\b\b\b%d seconds  ",(int)EZ_LERT);
    }
  } while(!ga.done());
  cout << "\nBest genome score: " << (ga.statistics().bestIndividual()).evaluate() << endl;
  cout << "Contents of the genome:\n" << ga.statistics().bestIndividual();
  cout << "Elapsed time: " << (double)( EZ_FINISH-EZ_START) / CLOCKS_PER_SEC<< " seconds for " << EZ_NB_EVALUATIONS << " evaluations.\n";
  cout << "Parameters: POP_SIZE=" << EZ_POP_SIZE << ", NB_GEN=" << EZ_NB_GEN << ", MUT_PROB=" << ga.pMutation() << ", CROSS_PROB=" << ga.pCrossover();
\STEADYSTATE  cout << ", OFF_POP=" << EZ_REPL_PERC << "%";
  char sTemp[50]; strcpy(sTemp,"\REPLACEMENT");
  if (!strcmp(sTemp,"Simple")) strcpy(sTemp,"Generational");
  else if (!strcmp(sTemp,"SteadyState")) strcpy(sTemp,"Plus");
  else if (!strcmp(sTemp,"Incremental")) strcpy(sTemp,"SteadyState");
  cout << "\n"<< "            Selector=\SELECTOR, Replacement="<<sTemp << endl;

#ifdef UNIX_OS
  for (i=1;i<=EZ_GDC_NbXValues;i++){
    EZ_GDC_Values[i]=(float)EZ_daFITNESS[i*EZ_GDC_Sampling+(EZ_NB_GEN-EZ_GDC_Sampling*EZ_GDC_NbXValues)];
  } 
  free (EZ_daFITNESS);

  if (!(EZ_GDC_OutputFile=fopen("EASEA.gif","w"))){
    fprintf(stderr,"Unable to open EASEA.gif");
    exit (1); 
  }
  out_graph( 250, 200,      /* short       width, height */
         EZ_GDC_OutputFile,        /* FILE*       open FILE pointer */
         GDC_LINE,     /* GDC_CHART_T chart type */
         EZ_GDC_NbXValues,  /* int         number of points per data set */
         EZ_GDC_XLabels,  /* char*[]     array of X labels */
         1,             /* int         number of data sets */
         EZ_GDC_Values    /* float[]     data set 1 */
         );                                                                                                            
  fclose(EZ_GDC_OutputFile);

  if (!system("test -L $HOME/.netscape/lock"))
    execvp(EZ_Netscape,EZ_NetscapeParams);
  else
    system("netscape -geometry 350x500 file:`pwd`/EASEA.html &");
#else
  free (EZ_daFITNESS);
#endif

  exit(0);
  return 0;
}

// If your compiler does not do automatic instantiation (e.g. g++ 2.6.8),
// then define the NO_AUTO_INST directive.  This will force the instantiation
// of the template classes that we use.  For some compilers (e.g. metrowerks)
// this must come after any specializations or you'll get 'multiply-defined'
// errors when you compile.
#ifdef NO_AUTO_INST
#include "GAList.cpp"
#include "GAListGe.cpp"
#if defined(__GNUG__)
template class GAList<int>;
template class GAListGenome<int>;
#else
GAList<int>;
GAListGenome<int>;
#endif
#endif

\TEMPLATE_END

